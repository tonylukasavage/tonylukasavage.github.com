<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: html5 | Tony Lukasavage]]></title>
  <link href="http://tonylukasavage.github.com/blog/categories/html5/atom.xml" rel="self"/>
  <link href="http://tonylukasavage.github.com/"/>
  <updated>2015-03-24T14:53:38-04:00</updated>
  <id>http://tonylukasavage.github.com/</id>
  <author>
    <name><![CDATA[Tony Lukasavage]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Are You Actually Saving Time With Mobile Frameworks?]]></title>
    <link href="http://tonylukasavage.github.com/blog/2011/03/10/are-you-actually-saving-time-with-mobile-frameworks-/"/>
    <updated>2011-03-10T10:37:00-05:00</updated>
    <id>http://tonylukasavage.github.com/blog/2011/03/10/are-you-actually-saving-time-with-mobile-frameworks-</id>
    <content type="html"><![CDATA[<h2>The Short, Blunt Version</h2>


<p><strong>DISCLAIMER</strong>: Don't leave me nasty comments if this is all you read.</p>

<p>Most of the available "cross platform" mobile frameworks are not as universally and uniformly compatible as they would be announced.  There are inconsistencies that make "code once, run everywhere" very unlikely without at least some tweaking.  The time spent fitting an app to one, universal mold can often force a sacrifice of even more time, quality, and usability.</p>

<p>Using HTML/CSS/JS for mobile development is seen as an advantage only to those who already have a great deal of experience with it.  I say this from a pure language perspective as it carries the obvious advantage of providing portable, standards based code.  If you don't have this experience with Javascript, but do have the talent and/or diversity of background necessary to learn the languages to develop natively, do so.</p>

<p>I'm not saying you can't build a multi-platform, high quality app with a mobile framework.  I am saying that it is not quite as easy as it may appear on paper.  This may seem counter-intuitive, but <span style="color: #ff0000;">as the complexity of your project grows, the less effective a "code once, run everywhere" approach will be</span>.  That said, most mobile frameworks do a terrific job of making small to medium sized projects available to a large audience in a short amount of time.</p>

<p>For the quick feature comparison of the mobile frameworks I'll talk about below, check out my prior post, "Appcelerator vs. PhoneGap vs. Adobe Air".</p>

<hr />




<h2>Naivity</h2>


<p>I approached the world of mobile development with the thought that a cross platform development framework was the one true path.  I mean, how else could a single developer keep up with the plethora of mobile OSes, SDKs, and devices?  And with that notion, I went forward in search of the silver bullet framework that would give me the coveted "code once, run everywhere" solution.</p>

<p>But as you may have expected, I haven't found it.  With my tunnel-vision focus on cross platform development I neglected to pay attention to the multitude of other key factors that can cost developers time.  I also neglected the fact that deploying to every mobile device imaginable is almost never the goal of a particular app.</p>

<p>So what are the problems I've run into?  How have they cost me time?  Does this outweigh the potential time saved with the "code once, run everywhere"?  Is "code once, run everywhere" really achievable for most apps?  Let's dig into these topics and see how they could impact your potential mobile development workflow.</p>

<hr/>




<h2>Most frameworks are babies</h2>


<p>Let's take a look at the 3 frameworks I've looked at so far:</p>

<ul>
    <li><strong>Appcelerator</strong> - mobile SDK started in 2009</li>
    <li><strong>PhoneGap</strong> - started in 2008</li>
    <li><strong>Adobe Air &amp; Flex Hero</strong> - Air for Android and the iOS packager came out in 2010.  Flex "Hero" is still beta.</li>
</ul>


<p>As you can see, all of these frameworks are very young.  And with that youth comes ambition, which in turn can lead to cut corners.  The  competion is fierce in a new and growing market. They know what they need to stand out: <span style="color: #ff0000;">features</span>.  Stability and adherence to standards aren't quite as eye-catching as an app that can leverage cool mobile APIs like geolocation and accelerometers.</p>

<p>It seems that in many cases the frameworks are spreading themselves thin at the expense of solid compatibility and stability.</p>

<h2>How "Cross Platform" Are These Frameworks?</h2>


<p>Here's the mobile OSes aforementioned claim to support:</p>

<ul>
    <li><strong>Appcelerator</strong> - iOS, Android, Blackberry (beta)</li>
    <li><strong>PhoneGap</strong> - iOS, Android, Blackberry, WebOS, Symbian</li>
    <li><strong>Adobe Air &amp; Flex Hero</strong> - iOS, Android, Blackberry Playbook</li>
</ul>


<p>Now here's been my experience with each so far, your mileage may vary.  I will try to keep it as high level as possible.</p>

<ul>
    <li><strong>Appcelerator</strong> - iOS is their flagship.  You can tell by the very Mac-ish look to their Titanium Developer project application that this is their focus.  Appcelerator does iOs very well.  Android on the other hand has been a bit frustrating.  Many features and even core functionality are lagging behind in Android in terms of stability.  Simple things like orientation lock and layouts work well in iOS but not so much in Android.  This leads to inconsistent behavior between the two platforms, which is kinda the whole point of the framework.

I have not yet tried Blackberry development, but if Android is a production release and has these issues, I worry what I may run into.</li>
    <li><strong>PhoneGap</strong> - <span style="color: #ff0000;">This is the one framework I've experimented with so far that has a relatively uniform experience across all its supported platforms</span>.  The core functionality is there, operates the same, and with a consistent level of performance.  Granted PhoneGap is an entirely contained web app and has no native UI component access, though <a href="http://docs.phonegap.com/" target="_blank">most APIs are supported</a>.  This, though, should be the expected experience with a cross platform mobile app.  Give me the same thing on every device to which I deploy!</li>
    <li><strong>Adobe Air &amp; Flex Hero</strong> - Because these mobile apps run against the Adobe Air runtime you get a nearly identical experience across the supported platforms.  Flex Hero comes with a wide array of mobile components for your use, though some are notable missing.  The big hitch with consistency is performance.

Blackberry Playbook development churns out great, performant content.  Blackberry made available an AS3 SDK along with the ability to use Flex Hero.  Because of this forethought and respect for the existing technology, Flash/Flex developers are really enjoying this platform and I think users will too.

On Android, Air performs OK.  There's just enough lag on transitions and load time to drive you nuts as a developer, but likely won't be a deal breaker for users.

iOS seems to be a sore point for some developers.  The performance is reported to be less than desirable when compared with the other supported platforms.  Also, the <a href="http://labs.adobe.com/technologies/packagerforiphone/" target="_blank">Adobe iOS packager</a> that allows you to deploy Adobe Air mobile applications to iOS currently only supports Air 2.0, leaving out some popular APIs like camera and video.  We are all familiar with the battles between Apple and Adobe and why these performance issues exist.  The users don't care though and are likely to turn away from apps that seem sluggish as these might.</li>
</ul>


<p>So as you can see, "cross platform" and "code once, run everywhere" aren't quite as cut and dry as we would be led to believe.  I'm not saying that frameworks should be dismissed for these reasons, but they simplicity of universal deployment and satisfactory user experience in many cases is overstated.</p>

<h2>Do You Really Need To Support All Those Mobile OSes</h2>


<p>I could ramble on about market share, market viability, and targeted deployment, but I'll just let these few charts do the talking and let you render your own decision:</p>

<h2>Javascript</h2>


<p>I'm not here to start a holy war about whether or not Javascript is quality language.  We all know the effectiveness of a programming language is largely determined by the person wielding it.  But let's be honest, Javascript is no Java, C#, or even Objective-C.  And with the exception of Adobe Air and Flex Hero, almost all mobile frameworks use HTML/CSS/JS as their technology stack.</p>

<p>There's no classes, no types, and the available IDEs and debugging facilities are weak in comparison to its native language SDK counterparts.  As I hear many of my Flash/Flex friends saying from time to time, its a reminder of all that was wrong with the original version of Actionscript.  jQuery and other frameworks make it more tolerable, but its still tough sledding when you are accustomed to a more full featured language.</p>

<h2>Debugging</h2>


<p>This is where you are ging to spend the majority of your life as a developer.  If you don't, you're a better dev than I.  And let me tell you something: debugging sucks in Javascript.  Compound this with the fact that it is pretty much impossible to debug Javascript on a mobile device and you have a recipe for may, many lost hours chasing bugs.</p>

<p>Let's look at Appcelerator and PhoneGap: <span style="color: #ff0000;"><del datetime="2011-03-10T18:24:52+00:00">They have no ability to debug on a device</del></span> (I've had suggestions to try <a href="http://pmuellr.github.com/weinre/" target="_blank">WEINRE</a> and <a href="http://jsconsole.com/remote-debugging.html" target="_blank">JSConsole</a>).  Appcelerator often refers to a "debug" function you can use, but it is simply a logging capability called debugging.  With PhoneGap the suggested method of debugging is running your code against the desktop version of Webkit and using its debugging capabilities.  Neither of these situation is very ideal.</p>

<p>Adobe Air and Flex Hero debug the way you would expect an application to be debugged.  Air can do full integrated, on-device debugging in a number of IDEs (<a href="http://www.jdoqocy.com/click-4249024-10772054" target="_top">Flash Builder</a> and <a href="https://www.cleverbridge.com/429/?affiliate=15006&amp;scope=cart&amp;cart=71011" target="_blank">FDT</a> spring to mind).  This is what should be expected.  While Javascript based mobile frameworks are using web technology, they can no longer expect developer to abide by the web's workflow.  When developing native apps we want application debugging, not web debugging.</p>

<p>Do not underestimate the impact that poor debugging capabilities will have on not only the timeline of your project, but also the quality.  In both cases, you just might be better served going the native route.</p>

<h2>2 Layers Of Potential Bugs</h2>


<p>We all know that Android, iOS, Blackberry, and any other mobile OS you may encounter is going to have bugs and quirks in its SDK.  The same could be said of all software.  If you are using a mobile framework to develop against these SDKs, you now have 2 layers of potential bugs and quirks.  It can often be difficult and time consuming to determine which one is the culprit... after you've ruled out your own code of course!</p>

<p>While PhoneGap and Adobe Air suffer from this to a degree, the impact is less on these two frameworks.  This is because they make no attempt to handle native components.  They rely on your own HTML/CSS/JS or Flex/AS3 components respectively to serve your UI.  Some see this as a drawback and taking away from the native user experience.  I, on the other hand, see it as a step towards true uniformity in your app.  <span style="color: #ff0000;">You need to make a decision: Do I want a native or uniform experience?</span></p>

<p>Appcelerator suffers more from this situation.  By taking their unique approach of offering a Javascript SDK by which you can create native components, you are given the opportunity to create a native experience without having to engage in native development.  This is very appealing to many developers.  I know it was to me.  The unfortunate side-effect of this is that you many times will not get exactly what you would expect out of a component.  Due to the need to abstract functionality in order to make one code set apply to many different mobile OS components, you may find configurability difficult.  Determining whether something is misbahving in your app because of your code, your framework, or your SDK becomes quite troubling.</p>

<hr/>




<h2>Summary</h2>


<p>I gave the summary at the beginning, since I don't know if a lot of you have the stomach for this much negativity in one blog post.  There was a lot to say and detail, but the short, blunt intro summary is my current sentiment on the state of mobile development.</p>

<p>Just to be clear, its not all gloom and doom for mobile frameworks.  Check out the post I did a little while back detailing all the areas where these mobile frameworks can make your life much easier.  And these frameworks are getting better everyday.  PhoneGap is quickly <a href="http://wiki.phonegap.com/w/page/28291160/roadmap-planning" target="_blank">closing the gap</a> (pun) between itself and the other mobile frameworks in terms of features.  Appcelerator is making some major moves by creating a community of Titans to bring more notoriety to the cause.  They are also due to release the first public beta of their new IDE, a fusion between <a href="http://www.appcelerator.com/" target="_blank">Titanium Developer</a> and <a href="http://www.aptana.com/" target="_blank">Aptana</a>, sure to help the current state of Javascript development.  And Adobe is aggressively garnering support for its <a href="http://labs.adobe.com/" target="_blank">pre-release programs</a> for Air, Flash Player, and Flash Builder.  I believe new features along with improved performance across all platforms is going to be the fruit of this labor.</p>

<p>So I haven't given up yet and will continue to actively pursue these platforms.  I may wait for a bit more dust to settle though before engaging in a large scale project with any of them.  I'm sure folks braver than I are more than able to have success doing so right now.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Box2D JS - Physics in HTML5 &amp; Javascript Guide]]></title>
    <link href="http://tonylukasavage.github.com/blog/2010/11/21/box2d-js---physics-in-html5--amp--javascript-guide/"/>
    <updated>2010-11-21T23:29:00-05:00</updated>
    <id>http://tonylukasavage.github.com/blog/2010/11/21/box2d-js---physics-in-html5--amp--javascript-guide</id>
    <content type="html"><![CDATA[<p style="text-align: center;"><a href="http://tonylukasavage.github.com/demos/box2djs/helloworld.html" class="fancybox.iframe"><img title="helloworld" src="http://tonylukasavage.github.com/images/helloworld_medium.jpg" alt="" width="624" height="275" /></a></p>


<p><strong>I hate to do it, but I highly recommend the <span style="color:#ff0000;">Google Chrome</span> browser for this demo.  In other browsers it may take a while to load and runs slower.</strong></p>

<p>&rarr; Click on the demo above or <a href="http://tonylukasavage.github.com/demos/box2djs/helloworld.html">here</a>, then right click to view source
&rarr; Download the <a href="http://sourceforge.net/projects/box2d-js/files/" target="_blank">Box2D JS library</a>
&rarr; Download the <a href="http://tonylukasavage.github.com/demos/box2djs/box2djs.js">concatenated version</a> (~350KB)
&rarr; Download the <a href="http://tonylukasavage.github.com/demos/box2djs/box2djs.min.js">minified version</a> (~170 KB)</p>

<h2>The Overview</h2>

<p>Some of you might remember the Box2DFlashAS3 demo I did a while ago.  Well here's its HTML5 counter-part, with the help of <a href="http://box2d-js.sourceforge.net/" target="_blank">Box2D JS</a>.  Box2D is the Javascript port of the <a href="http://box2dflash.sourceforge.net/" target="_blank">Box2DFlashAS3 library</a>, which in turn is a port of the <a href="http://www.box2d.org/">Box2D C++ library</a>.  Put simply, this library allows you to apply 2 dimensional physics to objects on your HTML5 canvas element.  Just click anywhere on the demo above to see what I mean.</p>

<p>The code behind this is a condensed, easier-to-follow version of the demo code available by viewing the page source at the <a href="http://box2d-js.sourceforge.net/" target="_blank">Box2D JS site</a>.  I personally found it a little tough to follow initially and really wanted to avoid the large amount of individual includes necessary to get it working.  To that end I created the concatenated and minified versions downloadable above.  So basically the includes necessary go from this:</p>

<p>``` javascript</p>

<!--[if IE]><script type="text/javascript" src="lib/excanvas.js"></script><![endif]-->


<script src="lib/prototype-1.6.0.2.js"></script>




<!-- box2djs -->


<script src='js/box2d/common/b2Settings.js'></script>


<script src='js/box2d/common/math/b2Vec2.js'></script>


<script src='js/box2d/common/math/b2Mat22.js'></script>


<script src='js/box2d/common/math/b2Math.js'></script>


<script src='js/box2d/collision/b2AABB.js'></script>


<script src='js/box2d/collision/b2Bound.js'></script>


<script src='js/box2d/collision/b2BoundValues.js'></script>


<script src='js/box2d/collision/b2Pair.js'></script>


<script src='js/box2d/collision/b2PairCallback.js'></script>


<script src='js/box2d/collision/b2BufferedPair.js'></script>


<script src='js/box2d/collision/b2PairManager.js'></script>


<script src='js/box2d/collision/b2BroadPhase.js'></script>


<script src='js/box2d/collision/b2Collision.js'></script>


<script src='js/box2d/collision/Features.js'></script>


<script src='js/box2d/collision/b2ContactID.js'></script>


<script src='js/box2d/collision/b2ContactPoint.js'></script>


<script src='js/box2d/collision/b2Distance.js'></script>


<script src='js/box2d/collision/b2Manifold.js'></script>


<script src='js/box2d/collision/b2OBB.js'></script>


<script src='js/box2d/collision/b2Proxy.js'></script>


<script src='js/box2d/collision/ClipVertex.js'></script>


<script src='js/box2d/collision/shapes/b2Shape.js'></script>


<script src='js/box2d/collision/shapes/b2ShapeDef.js'></script>


<script src='js/box2d/collision/shapes/b2BoxDef.js'></script>


<script src='js/box2d/collision/shapes/b2CircleDef.js'></script>


<script src='js/box2d/collision/shapes/b2CircleShape.js'></script>


<script src='js/box2d/collision/shapes/b2MassData.js'></script>


<script src='js/box2d/collision/shapes/b2PolyDef.js'></script>


<script src='js/box2d/collision/shapes/b2PolyShape.js'></script>


<script src='js/box2d/dynamics/b2Body.js'></script>


<script src='js/box2d/dynamics/b2BodyDef.js'></script>


<script src='js/box2d/dynamics/b2CollisionFilter.js'></script>


<script src='js/box2d/dynamics/b2Island.js'></script>


<script src='js/box2d/dynamics/b2TimeStep.js'></script>


<script src='js/box2d/dynamics/contacts/b2ContactNode.js'></script>


<script src='js/box2d/dynamics/contacts/b2Contact.js'></script>


<script src='js/box2d/dynamics/contacts/b2ContactConstraint.js'></script>


<script src='js/box2d/dynamics/contacts/b2ContactConstraintPoint.js'></script>


<script src='js/box2d/dynamics/contacts/b2ContactRegister.js'></script>


<script src='js/box2d/dynamics/contacts/b2ContactSolver.js'></script>


<script src='js/box2d/dynamics/contacts/b2CircleContact.js'></script>


<script src='js/box2d/dynamics/contacts/b2Conservative.js'></script>


<script src='js/box2d/dynamics/contacts/b2NullContact.js'></script>


<script src='js/box2d/dynamics/contacts/b2PolyAndCircleContact.js'></script>


<script src='js/box2d/dynamics/contacts/b2PolyContact.js'></script>


<script src='js/box2d/dynamics/b2ContactManager.js'></script>


<script src='js/box2d/dynamics/b2World.js'></script>


<script src='js/box2d/dynamics/b2WorldListener.js'></script>


<script src='js/box2d/dynamics/joints/b2JointNode.js'></script>


<script src='js/box2d/dynamics/joints/b2Joint.js'></script>


<script src='js/box2d/dynamics/joints/b2JointDef.js'></script>


<script src='js/box2d/dynamics/joints/b2DistanceJoint.js'></script>


<script src='js/box2d/dynamics/joints/b2DistanceJointDef.js'></script>


<script src='js/box2d/dynamics/joints/b2Jacobian.js'></script>


<script src='js/box2d/dynamics/joints/b2GearJoint.js'></script>


<script src='js/box2d/dynamics/joints/b2GearJointDef.js'></script>


<script src='js/box2d/dynamics/joints/b2MouseJoint.js'></script>


<script src='js/box2d/dynamics/joints/b2MouseJointDef.js'></script>


<script src='js/box2d/dynamics/joints/b2PrismaticJoint.js'></script>


<script src='js/box2d/dynamics/joints/b2PrismaticJointDef.js'></script>


<script src='js/box2d/dynamics/joints/b2PulleyJoint.js'></script>


<script src='js/box2d/dynamics/joints/b2PulleyJointDef.js'></script>


<script src='js/box2d/dynamics/joints/b2RevoluteJoint.js'></script>


<script src='js/box2d/dynamics/joints/b2RevoluteJointDef.js'></script>


<p>```</p>

<p>to this:</p>

<p>``` javascript</p>

<!--[if IE]><script type="text/javascript" src="lib/excanvas.js"></script><![endif]-->


<script src="lib/prototype-1.6.0.2.js"></script>


<script src="box2djs.min.js"></script>


<p>```</p>

<p>You still need to download Box2D JS for its dependencies on <a href="http://www.prototypejs.org/" target="_blank">Prototype</a> and <a href="http://excanvas.sourceforge.net/" target="_blank">excanvas</a>, but using my single file versions of the library will make getting started much cleaner and easier.  OK, enough of the back story, on to the code.</p>

<h2>The Code</h2>

<p>``` javascript
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"></p>

<pre><code>&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;title&gt;SavageLook.com - Box2D JS Hello World&lt;/title&gt;
&lt;!--[if IE]&gt;&lt;script type="text/javascript" src="lib/excanvas.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;
&lt;script src="lib/prototype-1.6.0.2.js"&gt;&lt;/script&gt;
&lt;script src="box2djs.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
var world;
var ctx;
var canvasWidth;
var canvasHeight;
var canvasTop;
var canvasLeft;

function drawWorld(world, context) {
    for (var j = world.m_jointList; j; j = j.m_next) {
        drawJoint(j, context);
    }
    for (var b = world.m_bodyList; b; b = b.m_next) {
        for (var s = b.GetShapeList(); s != null; s = s.GetNext()) {
            drawShape(s, context);
        }
    }

    ctx.font = 'bold 18px arial';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#000000';
    ctx.fillText("Click the screen to add more objects", 400, 20);
    ctx.font = 'bold 14px arial';
    ctx.fillText("Performance will vary by browser", 400, 40);

}

function drawJoint(joint, context) {
    var b1 = joint.m_body1;
    var b2 = joint.m_body2;
    var x1 = b1.m_position;
    var x2 = b2.m_position;
    var p1 = joint.GetAnchor1();
    var p2 = joint.GetAnchor2();
    context.strokeStyle = '#00eeee';
    context.beginPath();
    switch (joint.m_type) {
    case b2Joint.e_distanceJoint:
        context.moveTo(p1.x, p1.y);
        context.lineTo(p2.x, p2.y);
        break;

    case b2Joint.e_pulleyJoint:
        // TODO
        break;

    default:
        if (b1 == world.m_groundBody) {
            context.moveTo(p1.x, p1.y);
            context.lineTo(x2.x, x2.y);
        }
        else if (b2 == world.m_groundBody) {
            context.moveTo(p1.x, p1.y);
            context.lineTo(x1.x, x1.y);
        }
        else {
            context.moveTo(x1.x, x1.y);
            context.lineTo(p1.x, p1.y);
            context.lineTo(x2.x, x2.y);
            context.lineTo(p2.x, p2.y);
        }
        break;
    }
    context.stroke();
}

function drawShape(shape, context) {
    context.strokeStyle = '#ffffff';
    if (shape.density == 1.0) {
        context.fillStyle = "red";
    } else {
        context.fillStyle = "black";
    }
    context.beginPath();
    switch (shape.m_type) {
    case b2Shape.e_circleShape:
        {
            var circle = shape;
            var pos = circle.m_position;
            var r = circle.m_radius;
            var segments = 16.0;
            var theta = 0.0;
            var dtheta = 2.0 * Math.PI / segments;

            // draw circle
            context.moveTo(pos.x + r, pos.y);
            for (var i = 0; i &lt; segments; i++) {
                var d = new b2Vec2(r * Math.cos(theta), r * Math.sin(theta));
                var v = b2Math.AddVV(pos, d);
                context.lineTo(v.x, v.y);
                theta += dtheta;
            }
            context.lineTo(pos.x + r, pos.y);

            // draw radius
            context.moveTo(pos.x, pos.y);
            var ax = circle.m_R.col1;
            var pos2 = new b2Vec2(pos.x + r * ax.x, pos.y + r * ax.y);
            context.lineTo(pos2.x, pos2.y);
        }
        break;
    case b2Shape.e_polyShape:
        {
            var poly = shape;
            var tV = b2Math.AddVV(poly.m_position, b2Math.b2MulMV(poly.m_R, poly.m_vertices[0]));
            context.moveTo(tV.x, tV.y);
            for (var i = 0; i &lt; poly.m_vertexCount; i++) {
                var v = b2Math.AddVV(poly.m_position, b2Math.b2MulMV(poly.m_R, poly.m_vertices[i]));
                context.lineTo(v.x, v.y);
            }
            context.lineTo(tV.x, tV.y);
        }
        break;
    }
    context.fill();
    context.stroke();
}

function createWorld() {
    var worldAABB = new b2AABB();
    worldAABB.minVertex.Set(-1000, -1000);
    worldAABB.maxVertex.Set(1000, 1000);
    var gravity = new b2Vec2(0, 300);
    var doSleep = true;
    world = new b2World(worldAABB, gravity, doSleep);
    createGround(world);
    return world;
}

function createGround(world) {
    var groundSd = new b2BoxDef();
    groundSd.extents.Set(400, 30);
    groundSd.restitution = 0.0;
    var groundBd = new b2BodyDef();
    groundBd.AddShape(groundSd);
    groundBd.position.Set(400, 470);
    return world.CreateBody(groundBd);
}

function createBall(world, x, y) {
    var ballSd = new b2CircleDef();
    ballSd.density = 1.0;
    ballSd.radius = 20;
    ballSd.restitution = 0.5;
    ballSd.friction = 0.5;
    var ballBd = new b2BodyDef();
    ballBd.AddShape(ballSd);
    ballBd.position.Set(x,y);
    return world.CreateBody(ballBd);
}

function createHelloWorld() {
    // H
    createBox(world, 50, 420, 10, 20, false);
    createBox(world, 90, 420, 10, 20, false);
    createBox(world, 70, 395, 30, 5, false);
    createBox(world, 50, 370, 10, 20, false);
    createBox(world, 90, 370, 10, 20, false);

    // E
    createBox(world, 140, 435, 30, 5, false);
    createBox(world, 120, 420, 10, 10, false);
    createBox(world, 130, 405, 20, 5, false);
    createBox(world, 120, 390, 10, 10, false);
    createBox(world, 140, 375, 30, 5, true);

    // L
    createBox(world, 200, 435, 20, 5, false);
    createBox(world, 185, 400, 5, 30, false);

    // L
    createBox(world, 250, 435, 20, 5, false);
    createBox(world, 235, 400, 5, 30, false);

    // O
    createBox(world, 300, 435, 20, 5, false);
    createBox(world, 285, 405, 5, 25, false);
    createBox(world, 315, 405, 5, 25, false);
    createBox(world, 300, 375, 20, 5, false);

    // W
    createBox(world, 390, 435, 40, 5, false);
    createBox(world, 360, 390, 10, 40, false);
    createBox(world, 420, 390, 10, 40, false);
    createBox(world, 390, 415, 5, 15, false);

    // O
    createBox(world, 460, 435, 20, 5, false);
    createBox(world, 445, 405, 5, 25, false);
    createBox(world, 475, 405, 5, 25, false);
    createBox(world, 460, 375, 20, 5, false);

    // R
    createBox(world, 495, 410, 5, 30, false);
    createBox(world, 518, 425, 5, 15, false);
    createBox(world, 515, 405, 15, 5, false);
    createBox(world, 525, 390, 5, 10, false);
    createBox(world, 510, 375, 20, 5, false);

    // L
    createBox(world, 560, 435, 20, 5, false);
    createBox(world, 545, 400, 5, 30, false);

    // D
    createBox(world, 610, 435, 20, 5, false);
    createBox(world, 595, 405, 5, 25, false);
    createBox(world, 625, 405, 5, 25, false);
    createBox(world, 610, 375, 20, 5, false);

    // !
    createBox(world, 650, 430, 10, 10, false);
    createBox(world, 650, 380, 10, 40, false);
}

function createBox(world, x, y, width, height, fixed) {
    if (typeof(fixed) == 'undefined') fixed = true;
    var boxSd = new b2BoxDef();
    if (!fixed) boxSd.density = 1.0;
    boxSd.restitution = 0.0;
    boxSd.friction = 1.0;
    boxSd.extents.Set(width, height);
    var boxBd = new b2BodyDef();
    boxBd.AddShape(boxSd);
    boxBd.position.Set(x,y);
    return world.CreateBody(boxBd);
}

function step(cnt) {
    var stepping = false;
    var timeStep = 1.0/60;
    var iteration = 1;
    world.Step(timeStep, iteration);
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);
    drawWorld(world, ctx);
    setTimeout('step(' + (cnt || 0) + ')', 10);
}

// main entry point
Event.observe(window, 'load', function() {
    world = createWorld();
    ctx = $('canvas').getContext('2d');
    var canvasElm = $('canvas');
    canvasWidth = parseInt(canvasElm.width);
    canvasHeight = parseInt(canvasElm.height);
    canvasTop = parseInt(canvasElm.style.top);
    canvasLeft = parseInt(canvasElm.style.left);

    createHelloWorld();

    Event.observe('canvas', 'click', function(e) {
            if (Math.random() &gt; 0.5) {
                //createBox(world, Event.pointerX(e), Event.pointerY(e), 10, 10, false);
                createBox(world, e.clientX, e.clientY, 10, 10, false);
            } else {
                createBall(world, Event.pointerX(e), Event.pointerY(e));
            }
    });
    step();
});
&lt;/script&gt;
&lt;/head&gt;
&lt;body style="margin:0px;"&gt;
    &lt;canvas id="canvas" width='800' height='500' style="background-color:#eeeeee;"&gt;&lt;/canvas&gt;
&lt;/body&gt;
</code></pre>

<p> </html>
```</p>

<hr>


<h2>The Breakdown</h2>

<p>``` javascript
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"></p>

<pre><code>&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;title&gt;SavageLook.com - Box2D JS Hello World&lt;/title&gt;
&lt;!--[if IE]&gt;&lt;script type="text/javascript" src="lib/excanvas.js"&gt;&lt;/script&gt;&lt;![endif]--&gt;
&lt;script src="lib/prototype-1.6.0.2.js"&gt;&lt;/script&gt;
&lt;script src="box2djs.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>```</p>

<p>We start by including the scripts necessary to make Box2D JS work.  In order, we need excanvas (included in the Box2D JS distribution) in order to account for the fact that all current released version of Internet Explorer do not support the HTML canvas element.  Next we include the Prototype Javascript framework, also included with Box2D JS.  Finally we include my minified version of the library.  Now we can get started building physics into our canvas element.</p>

<hr>


<p>``` javascript</p>

<script type="text/javascript">
    var world;
    var ctx;
    var canvasWidth;
    var canvasHeight;
    var canvasTop;
    var canvasLeft;

    function drawWorld(world, context) {
        for (var j = world.m_jointList; j; j = j.m_next) {
            drawJoint(j, context);
        }
        for (var b = world.m_bodyList; b; b = b.m_next) {
            for (var s = b.GetShapeList(); s != null; s = s.GetNext()) {
                drawShape(s, context);
            }
        }

        ctx.font = 'bold 18px arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#000000';
        ctx.fillText("Click the screen to add more objects", 400, 20);
        ctx.font = 'bold 14px arial';
        ctx.fillText("Performance will vary by browser", 400, 40);

    }
```

Here we declare our global variables that define the "world" the physics exist in and the context, dimensions, and position of the canvas element.

Also we have our drawWorld() function that will, as the name implies, draw the shapes and joints that compose the Box2D JS world.  Each of these objects is iterated through and drawn individually.  They are added to the world with the createBody() function.  An important thing to note is that in the case of this demo, drawWorld() will be called with each "step".  Think of your canvas as an animation and each call to drawWorld() as a frame.  Should be a simple concept for you Flash devs out there ;)
<hr>

``` javascript
    function drawJoint(joint, context) {
        var b1 = joint.m_body1;
        var b2 = joint.m_body2;
        var x1 = b1.m_position;
        var x2 = b2.m_position;
        var p1 = joint.GetAnchor1();
        var p2 = joint.GetAnchor2();
        context.strokeStyle = '#00eeee';
        context.beginPath();
        switch (joint.m_type) {
        case b2Joint.e_distanceJoint:
            context.moveTo(p1.x, p1.y);
            context.lineTo(p2.x, p2.y);
            break;

        case b2Joint.e_pulleyJoint:
            // TODO
            break;

        default:
            if (b1 == world.m_groundBody) {
                context.moveTo(p1.x, p1.y);
                context.lineTo(x2.x, x2.y);
            }
            else if (b2 == world.m_groundBody) {
                context.moveTo(p1.x, p1.y);
                context.lineTo(x1.x, x1.y);
            }
            else {
                context.moveTo(x1.x, x1.y);
                context.lineTo(p1.x, p1.y);
                context.lineTo(x2.x, x2.y);
                context.lineTo(p2.x, p2.y);
            }
            break;
        }
        context.stroke();
    }

    function drawShape(shape, context) {
        context.strokeStyle = '#ffffff';
        if (shape.density == 1.0) {
            context.fillStyle = "red";
        } else {
            context.fillStyle = "black";
        }
        context.beginPath();
        switch (shape.m_type) {
        case b2Shape.e_circleShape:
            {
                var circle = shape;
                var pos = circle.m_position;
                var r = circle.m_radius;
                var segments = 16.0;
                var theta = 0.0;
                var dtheta = 2.0 * Math.PI / segments;

                // draw circle
                context.moveTo(pos.x + r, pos.y);
                for (var i = 0; i < segments; i++) {
                    var d = new b2Vec2(r * Math.cos(theta), r * Math.sin(theta));
                    var v = b2Math.AddVV(pos, d);
                    context.lineTo(v.x, v.y);
                    theta += dtheta;
                }
                context.lineTo(pos.x + r, pos.y);

                // draw radius
                context.moveTo(pos.x, pos.y);
                var ax = circle.m_R.col1;
                var pos2 = new b2Vec2(pos.x + r * ax.x, pos.y + r * ax.y);
                context.lineTo(pos2.x, pos2.y);
            }
            break;
        case b2Shape.e_polyShape:
            {
                var poly = shape;
                var tV = b2Math.AddVV(poly.m_position, b2Math.b2MulMV(poly.m_R, poly.m_vertices[0]));
                context.moveTo(tV.x, tV.y);
                for (var i = 0; i < poly.m_vertexCount; i++) {
                    var v = b2Math.AddVV(poly.m_position, b2Math.b2MulMV(poly.m_R, poly.m_vertices[i]));
                    context.lineTo(v.x, v.y);
                }
                context.lineTo(tV.x, tV.y);
            }
            break;
        }
        context.fill();
        context.stroke();
    }
```

Above are the body drawing functions: drawJoint() and drawShape().  I'm not going to get into much detail here, but just know that these functions are responsible for taking the physics bodies and giving them a visual representation.  They make calls to the canvas context 2D drawing API to create the shapes that give us our falling rectangles and circles.  This is the simplest case and requires no external dependencies.  In practical cases though, you will more likely find images or other more clever uses like this one:

<object width="640" height="390"><param name="movie" value="http://www.youtube.com/v/ZTwrQSOHdX0&hl=en_US&feature=player_embedded&version=3"></param><param name="allowFullScreen" value="true"></param><param name="allowScriptAccess" value="always"></param><embed src="http://www.youtube.com/v/ZTwrQSOHdX0&hl=en_US&feature=player_embedded&version=3" type="application/x-shockwave-flash" allowfullscreen="true" allowScriptAccess="always" width="640" height="390"></embed></object>
<hr>

``` javascript
    function createWorld() {
        var worldAABB = new b2AABB();
        worldAABB.minVertex.Set(-1000, -1000);
        worldAABB.maxVertex.Set(1000, 1000);
        var gravity = new b2Vec2(0, 300);
        var doSleep = true;
        world = new b2World(worldAABB, gravity, doSleep);
        createGround(world);
        return world;
    }
```

This is where the Box2D JS physics world is created.  We define the bounds for the AABB physics with the minVertex and maxVertex properties and set the vector of gravity.  After we create those we apply them to a newly created world and create the ground that will be the base of our scene.
<hr>

``` javascript
    function createGround(world) {
        var groundSd = new b2BoxDef();
        groundSd.extents.Set(400, 30);
        groundSd.restitution = 0.0;
        var groundBd = new b2BodyDef();
        groundBd.AddShape(groundSd);
        groundBd.position.Set(400, 470);
        return world.CreateBody(groundBd);
    }

    function createBall(world, x, y) {
        var ballSd = new b2CircleDef();
        ballSd.density = 1.0;
        ballSd.radius = 20;
        ballSd.restitution = 0.5;
        ballSd.friction = 0.5;
        var ballBd = new b2BodyDef();
        ballBd.AddShape(ballSd);
        ballBd.position.Set(x,y);
        return world.CreateBody(ballBd);
    }

        function createBox(world, x, y, width, height, fixed) {
        if (typeof(fixed) == 'undefined') fixed = true;
        var boxSd = new b2BoxDef();
        if (!fixed) boxSd.density = 1.0;
        boxSd.restitution = 0.0;
        boxSd.friction = 1.0;
        boxSd.extents.Set(width, height);
        var boxBd = new b2BodyDef();
        boxBd.AddShape(boxSd);
        boxBd.position.Set(x,y);
        return world.CreateBody(boxBd);
    }
```

Above we have the body create functions: createGround(), createBall(), and createBox().  Other than the obvious, let's talk about a few things going on here.  Each body is defined by a shape definition, and each shape definition has a number of properties that dictate how it will behave in the Box2D JS world  (see the <a href="http://www.kyucon.com/doc/box2d/" target="_blank">Box2D docs</a> for details).  Restitution, friction, and density affect how the shapes fall, move, and react.

The extents define the dimensions of the shapes, but probably not how you are accustomed.  Extents represent the distance from one corner of the shape to its center.  So a 100x100 box is actually defined by the extents shapeDef.extents.Set(50,50).

The shape definition is then used to define a body definition.  The body is then positioned in the world.  The positioning, like extents, is also based on the center of the body, not its corner.  Finally, the newly defined body, based on the shape definition, is added the world with the CreateBody() function.
<hr>

``` javascript
    function createHelloWorld() {
        // H
        createBox(world, 50, 420, 10, 20, false);
        createBox(world, 90, 420, 10, 20, false);
        createBox(world, 70, 395, 30, 5, false);
        createBox(world, 50, 370, 10, 20, false);
        createBox(world, 90, 370, 10, 20, false);

        // E
        createBox(world, 140, 435, 30, 5, false);
        createBox(world, 120, 420, 10, 10, false);
        createBox(world, 130, 405, 20, 5, false);
        createBox(world, 120, 390, 10, 10, false);
        createBox(world, 140, 375, 30, 5, true);

        // L
        createBox(world, 200, 435, 20, 5, false);
        createBox(world, 185, 400, 5, 30, false);

        // L
        createBox(world, 250, 435, 20, 5, false);
        createBox(world, 235, 400, 5, 30, false);

        // O
        createBox(world, 300, 435, 20, 5, false);
        createBox(world, 285, 405, 5, 25, false);
        createBox(world, 315, 405, 5, 25, false);
        createBox(world, 300, 375, 20, 5, false);

        // W
        createBox(world, 390, 435, 40, 5, false);
        createBox(world, 360, 390, 10, 40, false);
        createBox(world, 420, 390, 10, 40, false);
        createBox(world, 390, 415, 5, 15, false);

        // O
        createBox(world, 460, 435, 20, 5, false);
        createBox(world, 445, 405, 5, 25, false);
        createBox(world, 475, 405, 5, 25, false);
        createBox(world, 460, 375, 20, 5, false);

        // R
        createBox(world, 495, 410, 5, 30, false);
        createBox(world, 518, 425, 5, 15, false);
        createBox(world, 515, 405, 15, 5, false);
        createBox(world, 525, 390, 5, 10, false);
        createBox(world, 510, 375, 20, 5, false);

        // L
        createBox(world, 560, 435, 20, 5, false);
        createBox(world, 545, 400, 5, 30, false);

        // D
        createBox(world, 610, 435, 20, 5, false);
        createBox(world, 595, 405, 5, 25, false);
        createBox(world, 625, 405, 5, 25, false);
        createBox(world, 610, 375, 20, 5, false);

        // !
        createBox(world, 650, 430, 10, 10, false);
        createBox(world, 650, 380, 10, 40, false);
    }
```

Here's my addition to the Box2D JS code.  By using a series of stacked boxes I create the infamous programmer's first message, "Hello World!" (minus the comma, sorry).  No science or mystery here, just a lot of extents and positions for the boxes that compose my message.  And yes, I did cheat on the "E" and make it fixed, but not even I can defy the laws of physics for the sake of a code demo.
<hr>

``` javascript
    function step(cnt) {
        var stepping = false;
        var timeStep = 1.0/60;
        var iteration = 1;
        world.Step(timeStep, iteration);
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        drawWorld(world, ctx);
        setTimeout('step(' + (cnt || 0) + ')', 10);
    }
```

The step() function is the what makes the whole thing work.  step() is called over and over, at specified intervals, to create the animation of our scene on the canvas.  The world's Step() function is first called to apply one iteration of physics to our world's bodies.  Next we clear the visual representation of the scene so that it can be redrawn by our drawWorld() function.  Finally we set the interval timer so that step() will be called again.  Again, Flash devs will recognize this as a similar methodology as using the ENTER_FRAME event.
<hr>

``` javascript
    // main entry point
    Event.observe(window, 'load', function() {
        world = createWorld();
        ctx = $('canvas').getContext('2d');
        var canvasElm = $('canvas');
        canvasWidth = parseInt(canvasElm.width);
        canvasHeight = parseInt(canvasElm.height);
        canvasTop = parseInt(canvasElm.style.top);
        canvasLeft = parseInt(canvasElm.style.left);

        createHelloWorld();

        Event.observe('canvas', 'click', function(e) {
                if (Math.random() > 0.5) {
                    //createBox(world, Event.pointerX(e), Event.pointerY(e), 10, 10, false);
                    createBox(world, e.clientX, e.clientY, 10, 10, false);
                } else {
                    createBall(world, Event.pointerX(e), Event.pointerY(e));
                }
        });
        step();
    });
    </script>


<p>```</p>

<p>And this is where we kick everything off.  We use the Prototype event handling mechanism to wait until the window is loaded to start our code.  We first create the Box2D JS world and get the 2D context, dimensions, and position of our canvas.  After that I create the boxes that make up the Hello World message.  To finish up we listen for mouse clicks so that we can add more falling objects to the scene, since what good is a meticulously stacked Hello World if you can't turn it into a pile of rubble?  The first step() is kicked off and our scene is ready to go!</p>

<hr>


<p>``` html</p>

<pre><code>&lt;/head&gt;
&lt;body style="margin:0px;"&gt;
    &lt;canvas id="canvas" width='800' height='500' style="background-color:#eeeeee;"&gt;&lt;/canvas&gt;
&lt;/body&gt;
</code></pre>

<p> </html>
```</p>

<p>And to round out the breakdown, here's the actual instance of the canvas element.  Its a very simple container and allows for all the heavy lifting to be done in the Javascript.  Just a reminder, the canvas element will NOT work in Internet Explorer unless you have the conditional check that includes excanvas if necessary, or if you happen to be test driving the IE9 beta.</p>

<h2>The Summary</h2>

<p>OK, well that turned out a lot longer and wordier than I was expecting, but 2D physics being utilized in HTML5 and Javascript is a simple topic.  Hopefully, though, if you made it all the way through you have a much better understanding of how they all play together and how you will create Newtonian worlds of your own.</p>

<p><strong><small_rant></strong>The difference in performance between different browsers is enough to drive you crazy.  In my personal experience, Chrome > Firefox > IE.  I know its early in the game and that <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie-9/home" target="_blank">IE 9</a> and <a href="http://www.mozilla.com/en-US/firefox/beta/" target="_blank">Firefox 4</a> will likely be right up to par with Chrome, but its this lag and inconsistency across the board that has me spending most of my web development time in Flash and AS3.</p>

<p>Also, I had trouble making this work in all versions of IE, so if you run into any problems with a particular browser, please let me know.<strong></small_rant></strong></p>

<p><strong>NOTE:</strong> The concatenated version of Box2D JS is a convenience I offer so that you don't have to do all the individual includes shown on the Box2D JS site's demos.  The minified version is that same concatenated version run through <a href="http://www.crockford.com/javascript/jsmin.html" target="_blank">JSMin</a>.  Both versions are based on version 0.1.0 of Box2D JS.  I am not a contributor to the Box2D JS project, just someone making it simpler to get into.</p>
]]></content>
  </entry>
  
</feed>
