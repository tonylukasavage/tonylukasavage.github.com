<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: adobe air | Tony Lukasavage]]></title>
  <link href="http://tonylukasavage.github.com/blog/categories/adobe-air/atom.xml" rel="self"/>
  <link href="http://tonylukasavage.github.com/"/>
  <updated>2015-03-24T17:43:15-04:00</updated>
  <id>http://tonylukasavage.github.com/</id>
  <author>
    <name><![CDATA[Tony Lukasavage]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gonzo, an open source markdown editor]]></title>
    <link href="http://tonylukasavage.github.com/blog/2011/07/20/gonzo--an-open-source-markdown-editor/"/>
    <updated>2011-07-20T09:34:00-04:00</updated>
    <id>http://tonylukasavage.github.com/blog/2011/07/20/gonzo--an-open-source-markdown-editor</id>
    <content type="html"><![CDATA[<h2>Gonzo</h2>




<ul>
<li><a href="https://github.com/downloads/tonylukasavage/Gonzo/Gonzo_0.1.0_alpha.air">Gonzo 0.1.0 alpha release Air installer</a></li>
<li><a href="https://github.com/tonylukasavage/Gonzo">Gonzo on Github</a></li>
</ul>




<p>Gonzo is a lightweight, open source markdown editor written for Adobe Air for desktop using Flex 4 and AS3.  Its a stripped-to-the-bone application that serves one purpose: helping you deliver well formed and easy to proofread web content.</p>




<p><img src="http://tonylukasavage.github.com/images/gonzo_final.jpg" alt="Gonzo, the lightweight markdown editor" title="" /></p>




<h2>Why use markdown, I already know HTML?</h2>




<p>Rather than drone on about the pros and cons of each, I'll just present you with a simple example. You let me know which version you would rather proofread.</p>




<h3>HTML version</h3>


<p>```</p>

<h2>Here's a header</h2>




<p>Here's some content in a paragraph. And here's a link to <a href="http://www.google.com">Google</a> and another to my <a href="https://github.com/tonylukasavage">Github</a> account.</p>




<p>And here's another paragraph
    <blockquote>this time it contains a blockquote</blockquote>
</p>




<ul>
    <li>One of these lists' syntax</li>
    <li>has the following attributes:</li>
    <li>
        <ul>
            <li><b>intrusive</b></li>
            <li><b>ugly</b></li>
            <li><b>very hard to read</b></li>
        </ul>
    </li>
    <li>which one do you think it is?</li>
</ul>


<p>```</p>

<h3>Markdown version</h3>


<p>```</p>

<h2>Here's a header</h2>

<p>Here's some content in a paragraph. And here's a link to <a href="http://www.google.com">Google</a> and another to my <a href="https://github.com/tonylukasavage">Github</a> account.</p></p>

<p>And here's another paragraph</p>

<blockquote><p>this time it contains a blockquote</p></blockquote>

<ul>
<li>One of these lists' syntax</li>
<li>has the following attributes:

<ul>
<li>intrusive</li>
<li>ugly</li>
<li>very hard to read</li>
</ul>
</li>
<li>which one do you think it is?</li>
</ul>


<p>```</p>

<h2>Why should you use Gonzo?</h2>




<p>Well, unless you are writing content for the web, you probably shouldn't.  Gonzo is written specifically for those who want to leverage the readability of markdown over HTML when publishing web content.  So whether you are writing a Wordpress blog post, editing a wiki, or even just an answering a question on <a href="http://stackoverflow.com">StackOverflow</a>, Gonzo can make your life a whole lot easier.</p>




<p>In the spirit of markdown, I've added just enough features to increase efficiency while maintaining a content-driven writing experience. The idea is to only add features necessary for making web publishing easier.  All the effort saved by not implementing useless features was redirected into usability.</p>




<h2>Just Give Me The Feature List Already</h2>




<p>Yeah, I tend to skip the text and go right for the feature list too. Kudos to anyone who actually read the previous content before coming here.</p>




<ul>
<li><strong>Live HTML preview</strong> - You can actually see the raw and rendered HTML generated by your markdown in a preview pane.</li>
<li><strong>Multi-tab editing</strong> - Edit many documents at the same time.</li>
<li><strong>Cross platform</strong> - Works on any desktop that supports Adobe Air. </li>
<li><strong>Keyboard and (context) menu shortcuts</strong> - Creating markdown is even easier now with multiple was to create it.</li>
<li><strong>HTML Export</strong> - Export your generated HTML to a file so it can easily be uploaded or shared.</li>
<li><strong>Cheat Sheet</strong> - integrated markdown cheat sheet for beginners and vets alike.</li>
</ul>




<h2>Coming soon...</h2>




<p>This is the list of features I personally would like to have, as I'm the only user so far. Please let me know what <em>you</em> think would be a good addition to Gonzo's functionality.</p>




<ul>
<li><strong>yfrog integration</strong> - Wouldn't it be nice to browse to a file on your desktop, upload it as an image, and get a markdown link placed in your document in one click?  I think so too.</li>
<li><strong>bit.ly integration</strong> - see above </li>
<li><strong>Markdown toolbar shortcuts</strong> - Just in case the keyboard, context menu, and native menu shortcuts aren't enough...</li>
<li><strong>Preferences</strong> - Let users set things like fonts, colors, editor sizes, and eventually maybe even theming. </li>
<li><strong>Local settings</strong> - For persisting preferences between Gonzo sessions</li>
</ul>




<p>What else do you have in mind?</p>




<h2>Want to Contribute?</h2>




<p>Good! Like most open source projects, ongoing development will be heavily motivated by contributions and feedback from its community of developers and users. While Gonzo will continue to grow as I use and find features I want, its going to be you who determines if it matures into an application for the masses.</p>




<p>There's a number of ways you can contribute:</p>




<ul>
<li>Use it and let me know what you think.
<ul><li>What is it missing?</li>
<li>What am I doing wrong</li>
<li>What am I doing right?</li></ul></li>
<li>Fork <a href="https://github.com/tonylukasavage/Gonzo">Gonzo on Github</a>, start hacking away, and send me some pull requests. I'm very open to help, but bear in mind that its lightweight nature and usability should not be sacrificed for the sake of features.</li>
<li>Design help is very welcome. I'm a dev through and through, so it will remain spartan in frills unless someone else decides to add the polish.</li>
</ul>




<h2>Summary</h2>




<p>There's a lot to come yet for Gonzo. I still need to get the wiki up and running for basic docs.  I may even take the time to make a web page for it if it garners enough interest. Or none of this could happen and I could just continue to use it myself. Only time and feedback will tell.</p>




<p>If you do start using or hacking Gonzo, you can let me know here, on <a href="https://github.com/tonylukasavage/Gonzo">Github</a>, or on <a href="http://twitter.com/tonylukasavage">Twitter</a>.  I'd love to hear about your experience. In the meantime I'll continue using it to write my web content and keep improving it as I see fit.</p>




<p>Oh, and this entire post was written in markdown using Gonzo.  Here's a link to the <a href="http://savagelook.com/misc/gonzo.md.text">original markdown</a> for the blog post.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taking Notes on Node.js using Gonzo]]></title>
    <link href="http://tonylukasavage.github.com/blog/2011/06/22/taking-notes-on-node-js-using-gonzo/"/>
    <updated>2011-06-22T10:56:00-04:00</updated>
    <id>http://tonylukasavage.github.com/blog/2011/06/22/taking-notes-on-node-js-using-gonzo</id>
    <content type="html"><![CDATA[<h2>Gonzo</h2>

<p>In case you haven't heard me talking about it on <a href="http://twitter.com/#!/tonylukasavage">Twitter</a>, I'm creating my own markdown editor called <a href="https://github.com/tonylukasavage/Gonzo">Gonzo</a>. If you don't know what markdown is, read up on it at <a href="http://daringfireball.net/projects/markdown/syntax">John Gruber's (creator) blog</a>.  It was created as a way to make web based writing more readable from a writer's perspective.</p>

<p>Here's some of the highlights of the VERY young <strong>Gonzo</strong>:</p>

<ul style="padding-bottom:15px;">
<li>Its open source and <a href="https://github.com/tonylukasavage/Gonzo">hosted on Github</a></lI>
<li>Its written using Adobe Air for desktop, Flex 4, and AS3</lI>
<li>The markdown to HTML parsing is done using <a href="https://gist.github.com/648771">Charles Strahan's Showdown.as</a></lI>
<li>Uses <a href="http://gskinner.com/blog/archives/2007/04/free_extension.html">Grant Skinner's StringUtils.as</a></lI>
<li>Its <strong>3 days old</strong> as of the publishing date of the article</lI>
<li>It generates HTML as you type markdown and shows it live in a preview panel</lI>
<li>Counts your words for those web writers trying to hit quotas</lI>
</ul>


<h2>Test Run</h2>

<p>Last night I took <strong>Gonzo</strong> for its maiden voyage in "production." I went to a meetup of the <a href="http://www.meetup.com/Pittsburgh-JavaScript-Developers/">Pittsburgh Javascript Developers</a> and discussed <a href="http://nodejs.org/">Node.js</a>.  I've never looked at Node.js before as server side Javascript always seemed like the avenue of a one trick pony.  After shedding my preconceived notions, it became apparent that using one language throughout your entire technology stack could work miracles with your efficiency.  But its young, alpha, and it changes a lot.</p>

<p>Rather than ramble on from a beginner's stand point, I'll leave you with the notes I took last night at the meetup using <strong>Gonzo</strong>.  First, I'll show you the notes as I entered into <strong>Gonzo</strong>.  Like I said at the beginning, if markdown is unfamiliar, <a href="http://daringfireball.net/projects/markdown/syntax">read up</a>.  Just one glance shows you how much more readable and editable it is than typical HTML markup.</p>

<h2>My Notes in Markdown</h2>

<p>```</p>

<h2>Node.js</h2>

<h3>Overview</h3>

<ul>
<li>Server side JS.</li>
<li>HTTP/TCP built in</li>
<li>non-blocking, event driven, 1 thread (launches process into event queue)</li>
<li>not suitable for CPU intensive work</li>
<li>Node.js is alpha and changes a lot between revisions</li>
<li>for unix, not Windows friendly</li>
<li>everything is a callback and gets its own process

<ul>
<li>lots of nested callbacks</li>
</ul>
</li>
<li>has to run from command line, no GUI for management.</li>
<li>you can use it as a scripting language like ruby or perl

<ul>
<li>does not have to be event driven if ran this way.</li>
</ul>
</li>
<li>Having it server side allows you to use JS up and down your whole technology stack</li>
</ul>


<h3>NPM</h3>

<ul>
<li>Node package managaer</li>
<li>A lot like CPAN for perl</li>
</ul>


<h3>Modules</h3>

<ul>
<li><a href="https://github.com/joyent/node/wiki/modules">100's of modules</a></li>
<li>examples

<ul>
<li>Sizzle

<ul>
<li>DOM selections and traversing</li>
</ul>
</li>
<li>Paperboy

<ul>
<li>serves static files</li>
</ul>
</li>
<li>Jade

<ul>
<li>templating engine</li>
</ul>
</li>
<li>ExpressJS

<ul>
<li>web framework</li>
<li>use it to deliver RESTful services</li>
</ul>
</li>
<li>zombie headless browser

<ul>
<li>useful for testing Node driven services</li>
<li>assertions against returned data</li>
<li>DOM traversing is all custom code (why?!)</li>
</ul>
</li>
<li>Coffeescript</li>
<li>multiple cores w/ web workers</li>
<li>Node Inspector

<ul>
<li>debugger

<ul>
<li>breakpoints</li>
<li>call stack</li>
<li>watch expressions</li>
</ul>
</li>
<li>command line</li>
<li>runs in a webkit browser</li>
<li>based on google's v8 engine</li>
</ul>
</li>
</ul>
</li>
</ul>


<h3>Basic Server</h3>

<pre><code>var http = require("http");

http.createServer(function (request, response) {
    response.writeHead("Content-Type: "text/html");
    response.write("&lt;html&gt;&lt;/html&gt;");
    response.end();
}).listen(8081);
</code></pre>

<h3>Emitters</h3>

<p>Emitters are used to counter nesting of code. Should probably use constants to define emitter names. Add parameters afer emitter name in <code>emit()</code> to pass to callback.</p>

<pre><code>emitter.emit('eventName', param1, param2);
emitter.on('eventName', function(param1, param2) {
    // do stuff
});
</code></pre>

<p>```</p>

<p>And now, through the magic of <strong>Gonzo</strong> and Showdown.as, we get to see the markdown translated into HTML.  You can then take the translated HTML and publish it to the web, allowing it to leverage any CSS and formatting your target venue has in place.  Again, notice how much more readable the markdown version is than this HTML version.</p>

<h2>My Notes Translated to HTML via Gonzo</h2>

<p>``` html</p>

<h2>Node.js</h2>




<h3>Overview</h3>




<ul>
<li>Server side JS. </li>
<li>HTTP/TCP built in</li>
<li>non-blocking, event driven, 1 thread (launches process into event queue)</li>
<li>not suitable for CPU intensive work</li>
<li>Node.js is alpha and changes a lot between revisions</li>
<li>for unix, not Windows friendly</li>
<li>everything is a callback and gets its own process
<ul><li>lots of nested callbacks</li></ul></li>
<li>has to run from command line, no GUI for management.</li>
<li>you can use it as a scripting language like ruby or perl
<ul><li>does not have to be event driven if ran this way.</li></ul></li>
<li>Having it server side allows you to use JS up and down your whole technology stack</li>
</ul>




<h3>NPM</h3>




<ul>
<li>Node package managaer</li>
<li>A lot like CPAN for perl</li>
</ul>




<h3>Modules</h3>




<ul>
<li><a href="https://github.com/joyent/node/wiki/modules">100's of modules</a></li>
<li>examples
<ul><li>Sizzle
<ul><li>DOM selections and traversing</li></ul></li>
<li>Paperboy
<ul><li>serves static files</li></ul></li>
<li>Jade
<ul><li>templating engine</li></ul></li>
<li>ExpressJS
<ul><li>web framework</li>
<li>use it to deliver RESTful services</li></ul></li>
<li>zombie headless browser
<ul><li>useful for testing Node driven services</li>
<li>assertions against returned data</li>
<li>DOM traversing is all custom code (why?!)</li></ul></li>
<li>Coffeescript</li>
<li>multiple cores w/ web workers</li>
<li>Node Inspector
<ul><li>debugger
<ul><li>breakpoints</li>
<li>call stack</li>
<li>watch expressions</li></ul></li>
<li>command line</li>
<li>runs in a webkit browser</li>
<li>based on google's v8 engine</li></ul></li></ul></li>
</ul>




<h3>Basic Server</h3>




<pre><code>var http = require("http");

http.createServer(function (request, response) {
    response.writeHead("Content-Type: "text/html");
    response.write("<html></html>");
    response.end();
}).listen(8081);
</code></pre>




<h3>Emitters</h3>




<p>Emitters are used to counter nesting of code. Should probably use constants to define emitter names. Add parameters after emitter name in <code>emit()</code> to pass to callback.</p>




<pre><code>emitter.emit('eventName', param1, param2);
emitter.on('eventName', function(param1, param2) {
    // do stuff
});
</code></pre>


<p>```</p>

<p>And finally below is the above generated HTML copied directly into my blog.  The CSS that governs my blog does its work on the elements and makes it look relatively web ready.  Obviously if I put a little more effort in (as I will soon), I can tailor the CSS to play well with my generated HTML.  For now, though, you can see the basic formatting applied.  So without cluttering your writing with HTML you can still effortlessly generate web ready content.</p>

<h2>Gonzo Generated HTML on my Blog</h2>

<h2>Node.js</h2>




<h3>Overview</h3>




<ul>
<li>Server side JS. </li>
<li>HTTP/TCP built in</li>
<li>non-blocking, event driven, 1 thread (launches process into event queue)</li>
<li>not suitable for CPU intensive work</li>
<li>Node.js is alpha and changes a lot between revisions</li>
<li>for unix, not Windows friendly</li>
<li>everything is a callback and gets its own process
<ul><li>lots of nested callbacks</li></ul></li>
<li>has to run from command line, no GUI for management.</li>
<li>you can use it as a scripting language like ruby or perl
<ul><li>does not have to be event driven if ran this way.</li></ul></li>
<li>Having it server side allows you to use JS up and down your whole technology stack</li>
</ul>




<h3>NPM</h3>




<ul>
<li>Node package managaer</li>
<li>A lot like CPAN for perl</li>
</ul>




<h3>Modules</h3>




<ul>
<li><a href="https://github.com/joyent/node/wiki/modules">100's of modules</a></li>
<li>examples
<ul><li>Sizzle
<ul><li>DOM selections and traversing</li></ul></li>
<li>Paperboy
<ul><li>serves static files</li></ul></li>
<li>Jade
<ul><li>templating engine</li></ul></li>
<li>ExpressJS
<ul><li>web framework</li>
<li>use it to deliver RESTful services</li></ul></li>
<li>zombie headless browser
<ul><li>useful for testing Node driven services</li>
<li>assertions against returned data</li>
<li>DOM traversing is all custom code (why?!)</li></ul></li>
<li>Coffeescript</li>
<li>multiple cores w/ web workers</li>
<li>Node Inspector
<ul><li>debugger
<ul><li>breakpoints</li>
<li>call stack</li>
<li>watch expressions</li></ul></li>
<li>command line</li>
<li>runs in a webkit browser</li>
<li>based on google's v8 engine</li></ul></li></ul></li>
</ul>




<h3>Basic Server</h3>




<pre><code>var http = require("http");

http.createServer(function (request, response) {
    response.writeHead("Content-Type: "text/html");
    response.write("<html></html>");
    response.end();
}).listen(8081);
</code></pre>




<h3>Emitters</h3>




<p>Emitters are used to counter nesting of code. Should probably use constants to define emitter names. Add parameters after emitter name in <code>emit()</code> to pass to callback.</p>




<pre><code>emitter.emit('eventName', param1, param2);
emitter.on('eventName', function(param1, param2) {
    // do stuff
});
</code></pre>




<div style="height:15px;"></div>


<h2>Screenshot of Gonzo in Action</h2>

<p><a href="http://tonylukasavage.github.com/images/gonzo_example.jpg"><img src="http://tonylukasavage.github.com/images/gonzo_example-e1308748863352.jpg" alt="Gonzo in action" title="Gonzo in action" width="700" height="474" class="alignnone size-full wp-image-3169" /></a></p>

<h2>Summary and TODO</h2>

<p>Right now what is shown here is basically the extent of <strong>Gonzo's</strong> functionality.  It's very young, but I plan to develop it aggressively.  After this post, all of my blog content will likely first be written in markdown in <strong>Gonzo</strong>.  I welcome contributors to the <a href="https://github.com/tonylukasavage/Gonzo">Gonzo Github repository</a>, but in all honesty, I'd wait a week or two before joining in.  Its likely to change A LOT over that period of time.</p>

<p>I'll end with the current TODO list for Gonzo.  Please feel free to add your own idea in the comments.</p>

<ul>
<li>Add ability to edit and apply CSS within Gonzo</li>
<li>More robust "project" environment to allow grouping of markdown and CSS with generated HTML</li>
<li>Spell Checker, likely via <a href="http://labs.adobe.com/technologies/squiggly/">Squiggly</a></li>
<li>Major UI polish <em>(gonna need help here)</em></li>
<li>Create Mac and Windows native downloads on the <a href="https://github.com/tonylukasavage/Gonzo">Github site</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Repper for Blackberry Playbook with Full Source]]></title>
    <link href="http://tonylukasavage.github.com/blog/2011/03/23/repper-for-blackberry-playbook-with-full-source/"/>
    <updated>2011-03-23T09:09:00-04:00</updated>
    <id>http://tonylukasavage.github.com/blog/2011/03/23/repper-for-blackberry-playbook-with-full-source</id>
    <content type="html"><![CDATA[<h2>The Code</h2>


<ul style="padding-top: 20px; padding-bottom: 20px;">
    <li><a href="https://github.com/tonylukasavage/Repper-playbook" target="_blank">Repper-playbook on Github</a> -- Full source code and Flash Builder "Burrito" project files</li>
</ul>




<h2>The Overview</h2>


<p>I mentioned this week that if you hustle you can still get yourself a <a href="http://us.blackberry.com/developers/tablet/playbook_offer.jsp" target="_blank">free Blackberry Playbook</a>.  Just follow <a href="http://savagelook.com/blog/actionscript3/procrastinators-guide-to-a-free-blackberry-playbook">my procrastinator's guide</a> and you could very well still have enough time to make it.  I also made posted a while ago the incredibly simple process of porting <a href="https://market.android.com/details?id=air.Repper" target="_blank">Repper</a>, my fitness calculator mobile app written with <a href="http://labs.adobe.com/technologies/flexsdk_hero/" target="_blank">Flex "Hero"</a>, to the Playbook.  If that wasn't enough for you, here's one more bit of charity to motivate to try and beat that March 31st, 2011 deadline to submit an app for a free Playbook.</p>

<p>In the <a href="https://github.com/tonylukasavage/Repper-playbook" target="_blank">Github link</a> at the top I've included the full source and project files for Flash Builder "Burrito" for Repper.  Yep, everything it took to make a Playbook app that was submitted and approved is included within.  Take a look, pull it down, load it up, and see how a simple, functional app can get you a free tablet.  If you are wondering what your time is worth in comparison to the effort necessary, the model that developers are likely to receive (16 GB) is being priced at $500.  Seems a fair trade for a few hours of your time.</p>

<p>So now you have a guide to getting a Blackberry Playbook app submitted as quickly as possible and full source code for a project that has already been approved.  Pair that with the fact that I've not heard of one functional app not being approved, you are completely out of excuses to not cash in on this offer.  Dig in and get it done.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From Air for Android to Blackberry Playbook in seconds]]></title>
    <link href="http://tonylukasavage.github.com/blog/2011/02/21/from-air-for-android-to-blackberry-playbook-in-seconds/"/>
    <updated>2011-02-21T11:19:00-05:00</updated>
    <id>http://tonylukasavage.github.com/blog/2011/02/21/from-air-for-android-to-blackberry-playbook-in-seconds</id>
    <content type="html"><![CDATA[<h1><span style="font-weight: bold; font-size: 16px;">Overview</span></h1>




<p style="text-align: left;"><strong>NOTE</strong>: all source code is available for <a href="https://github.com/tonylukasavage/Repper" target="_blank">Repper at Github</a>.</p>


<p style="text-align: left;">The above image shows my <a href="http://savagelook.com/blog/actionscript3/repper-my-first-flex-hero-mobile-app" target="_self">Air for Android app Repper</a> ported over to the Blackberry Playbook.  The most remarkable thing about this port? It literally took about 60 seconds to complete!  Here is the shockingly simple, comprehensive list of steps I took to accomplish this:</p>




<ol>
    <li>Create a new Flex mobile project in <a href="http://labs.adobe.com/technologies/flashbuilder_burrito/" target="_blank">Flash Builder "Burrito"</a> to <a href="http://docs.blackberry.com/en/developers/deliverables/25068/Install_the_BlackBerry_Tablet_SDK_1347129_11.jsp" target="_blank">target the Blackberry Playbook</a></li>
    <li>Copied the project files from my original Repper project to the new project</li>
    <li>Set up the <a href="http://docs.blackberry.com/en/developers/deliverables/25068/Run_app_FB45_1397696_11.jsp" target="_blank">Playbook simulator run settings</a> in my new project</li>
    <li>Clicked "Run" and voila, Repper on the Playbook!</li>
</ol>


<p style="text-align: left;">All components scaled properly.  All layouts fit to the available screen space appropriately.  All orientation transitions performed as expected.  How was this achieved without having to write a single line of device specific code?  It comes down to 3 simple things: Adobe Air, fluid layouts, and vector graphics skinning via Flex MXML.</p>




<h1><span style="font-weight: bold; font-size: 16px;">Adobe Air</span></h1>


<p style="text-align: left;">Blackberry's use of the <a href="http://us.blackberry.com/developers/tablet/adobe.jsp" target="_blank">Adobe Air SDK for its Playbook development</a> lets Flash/Air/Flex/AS3 developers leverage existing expertise and code to create apps.  The Air SDK for the Playbook also makes available QNX components to give Playbook apps a Blackberry look and feel.  You can choose from either.  This way Flex developers can use their existing paradigms and pure AS3 developers can make use of Blackberry's QNX components.  You can even use both as Renaun Erickson details in <a href="http://renaun.com/blog/2010/12/using-mxml-with-qnx-ui-components-for-the-playbook/" target="_blank">this post</a>.</p>


<p style="text-align: left;">For me the big win was taking Repper, a <a href="http://labs.adobe.com/technologies/flexsdk_hero/" target="_blank">Flex "Hero" </a> app for Android, and porting it directly, unchanged into a working Playbook app.  The Playbook Adobe Air SDK supports Flex "Hero" so everything just worked right out of the gate.  That's the kind of portability that lets an independent developer be extremely productive.</p>




<h1><span style="font-weight: bold; font-size: 16px;">Fluid Layout</span></h1>


<p style="text-align: left;">Using fluid layouts with little to no defined pixel dimensions is key to writing a multi-screen app.  Take a look at this excerpt from the main <a href="https://github.com/tonylukasavage/Repper/blob/master/src/views/RepperHome.mxml" target="_blank">RepperHome.mxml view</a>.</p>


<p>``` xml</p>

<pre><code>    &lt;s:HGroup id="landscapeGroup" includeIn="landscape" height="100%" width="100%"
          paddingTop="{this.height*0.03}" paddingBottom="{this.height*0.03}" paddingLeft="{this.height*0.03}"
          paddingRight="{this.height*0.03}" gap="{this.height*0.03}" verticalAlign="middle"&gt;
    &lt;s:SkinnableContainer id="landscapeInput" width="36%" skinClass="RepperInputSkin"&gt;
        &lt;s:layout&gt;
            &lt;s:VerticalLayout paddingTop="{this.height*0.06}" paddingLeft="{this.height*0.06}"
                              paddingRight="{this.height*0.06}" paddingBottom="{this.height*0.06}"
                              gap="{landscapeInput.height*0.04}" horizontalAlign="right"/&gt;
        &lt;/s:layout&gt;
        &lt;s:HGroup width="100%" verticalAlign="middle" gap="0"&gt;
            &lt;s:Label text="Weight" width="65%" color="0x000000" fontWeight="bold" fontSize="32"/&gt;
            &lt;s:TextInput width="35%" text="{inputWeight}" keyUp="onWeightKeyUp(event)" restrict="0-9."
                         contentBackgroundColor="0xffffff" color="0x000000"/&gt;
        &lt;/s:HGroup&gt;
        &lt;s:HGroup width="100%" verticalAlign="middle" gap="0"&gt;
            &lt;s:Label text="# of reps" width="65%" color="0x000000" fontWeight="bold" fontSize="32"/&gt;
            &lt;s:TextInput width="35%" text="{inputReps}" keyUp="onRepsKeyUp(event)" restrict="0-9"
                         contentBackgroundColor="0xffffff" color="0x000000" focusIn="textinput1_focusInHandler(event)"/&gt;
        &lt;/s:HGroup&gt;
        &lt;s:Button label="Rep It" click="recalculate();" chromeColor="#111111" /&gt;
    &lt;/s:SkinnableContainer&gt;
    &lt;local:VDataGroup width="32%" height="100%" dataProvider="{repValues1}" itemRenderer="RepperEntry"/&gt;
    &lt;local:VDataGroup width="32%" height="100%" dataProvider="{repValues2}" itemRenderer="RepperEntry"/&gt;
&lt;/s:HGroup&gt;
</code></pre>

<p>```</p>

<p style="text-align: left;">If you look at every component and container in this chunk of Flex MXML you'll notice that no defined pixel dimensions are used.  Every component's size is determined using percentages or data bindings.  I'm not going to lie, specifying dimensions in this manner will take more time and requires a bit of trial and error to get right.  It helps if you do it with the expectation that another, dissimilar device will be using this same layout in the future.  I did, and in this case the little bit of extra forethought paid off huge in terms of portability.</p>


<p>Because of design via fluid layouts, Repper appears properly in both portrait and landscape orientation on the Blackberry Playbook with no additional effort.</p>

<h1><span style="font-weight: bold; font-size: 16px;">Vector Graphics via Flex MXML Skinning</span></h1>


<p style="text-align: left;">The final factor that made Repper such a breeze to port to the Playbook was Flex Hero's ability to create vector graphics via Flex MXML.  By utilizing this capability you can create skins for your components that scale as the app scales.  No external artwork of any kind is necessary.  While this is not ideal for designers or highly stylized apps, a developer like me loves it.

Here's another excerpt from Repper.  This time it shows how I used fluid dimensions once again to create vector graphic skins for my <a href="https://github.com/tonylukasavage/Repper/blob/master/src/RepperEntry.mxml" target="_blank">RepperEntry</a> components via the <a href="https://github.com/tonylukasavage/Repper/blob/master/src/RepperEntrySkin.mxml" target="_blank">RepperEntrySkin.mxml class</a></p>


<p>``` xml</p>

<pre><code>&lt;s:Rect id="background" x="0" y="{this.height/6}" height="66%" width="100%" radiusX="10" radiusY="10"&gt;
&lt;s:filters&gt;
    &lt;s:DropShadowFilter blurX="16" blurY="16"/&gt;
&lt;/s:filters&gt;
&lt;s:stroke&gt;
    &lt;s:SolidColorStroke weight="3"/&gt;
&lt;/s:stroke&gt;
    &lt;s:fill&gt;
    &lt;s:LinearGradient rotation="-90"&gt;
        &lt;s:GradientEntry color="#bbbbbb"/&gt;
        &lt;s:GradientEntry color="#ffffff"/&gt;
        &lt;/s:LinearGradient&gt;
    &lt;/s:fill&gt;
&lt;/s:Rect&gt;
&lt;s:Rect x="0" y="{this.height/6}" height="66%" width="60%" radiusX="10" radiusY="10"&gt;
&lt;s:filters&gt;
    &lt;s:DropShadowFilter blurX="8" blurY="8" angle="0"/&gt;
&lt;/s:filters&gt;
&lt;s:stroke&gt;
    &lt;s:SolidColorStroke weight="3"/&gt;
&lt;/s:stroke&gt;
&lt;s:fill&gt;
    &lt;!--- @private --&gt;
    &lt;s:LinearGradient rotation="-90"&gt;
        &lt;s:GradientEntry color="#000000"/&gt;
        &lt;s:GradientEntry color="#444444"/&gt;
    &lt;/s:LinearGradient&gt;
    &lt;!-- &lt;s:SolidColor color="#333333"/&gt; --&gt;
&lt;/s:fill&gt;
&lt;/s:Rect&gt;
</code></pre>

<p>```</p>

<p>As you can see, percentages and binding are used to create skins for my components that are appropriately scaled regardless of the dimensions of the device.  Not having to create skin resources for each device and orientation is a tremendous time saver.  Especially for someone like myself who has no patience or talent for it.</p>

<h1><span style="font-weight: bold; font-size: 16px;">Summary</span></h1>


<p>Lesson for the day: with a little forethought and a penchant for Adobe Air, magic can happen.  OK, maybe not magic, but you'll have more time to explore the possibility of creating magic now that you won't be wasting it on porting your mobile apps.  Yes, I know, I've griped a bit lately about Flex Hero on <a href="http://twitter.com/#!/tonylukasavage" target="_blank">twitter</a>, but there are undoubtedly some things it does very well.</p>

<p>In fact, if you think about it, anyone that openly supports Adobe and their efforts to create a viable cross-platform mobile development environment has done very well with it.  I'm trying to think of who isn't supporting it?  Who's at the "core" of the issue?  I feel like day to day they are trying to keep the doctor away.  Supporting Adobe should be as appealing as American pie.  Oh well, hopefully some day they will have their thinking jolted like Isaac Newton did from a falling piece of fruit.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Good, The Bad, and The Ugly of Flex "Hero"]]></title>
    <link href="http://tonylukasavage.github.com/blog/2011/02/08/the-good--the-bad--and-the-ugly-of-flex--hero-/"/>
    <updated>2011-02-08T10:50:00-05:00</updated>
    <id>http://tonylukasavage.github.com/blog/2011/02/08/the-good--the-bad--and-the-ugly-of-flex--hero-</id>
    <content type="html"><![CDATA[<h1><span style="font-weight: bold; font-size: 16px;">Disclaimer</span></h1>


<p>This article is from the perspective of someone whose AS3 and Flex experience is measured in months.  This is meant to show those who aren't long time Flash developers what they can expect with <a href="http://labs.adobe.com/technologies/flexsdk_hero/" target="_blank">Flex "Hero"</a>, <a href="http://labs.adobe.com/technologies/flashbuilder_burrito/" target="_blank">Flash Builder "Burrito"</a>, and <a href="http://www.adobe.com/products/air/" target="_blank">Air for Android</a>.  But I didn't go in alone, the Adobe community is full of smart and helpful people, just check my <a href="http://twitter.com/#!/tonylukasavage/following" target="_blank">Twitter follower list</a> to see some of the names that helped.  Particular thanks to <a href="http://twitter.com/#!/killerspaz" target="_blank">@killerspaz</a>, <a href="http://twitter.com/#!/jesterxl" target="_blank">@jesterxl</a>, and <a href="http://twitter.com/#!/jonbcampos" target="_blank">@jonbcampos</a>.</p>

<h1><span style="font-weight: bold; font-size: 16px;">Overview</span></h1>


<p>Recently I wrapped up my first Flex "Hero" Air for Android app, <a href="https://market.android.com/details?id=air.Repper" target="_blank">Repper</a>.  You can read my earlier blog post about it to download, get source code, or just learn more about it.  I learned a lot about mobile development and deployment, but I want to talk specifically about Flex "Hero" and Flash Builder "Burrito".  Here's this developer's experience and perspective with using Adobe's workflow for mobile development.</p>

<h1><span style="font-weight: bold; font-size: 16px;">The Good</span></h1>


<ul>
    <li> <strong>The Flash Builder "Burrito" workflow</strong> for building Android apps is fantastic.  It was a breeze to setup a basic project and be testing it live on my Droid X.  Some of the specific things I really liked were:
<ul>
    <li>Pre-built templates for projects, components, skins, item renderers, and more speed up the development process</li>
    <li>Built-in emulation for various Android devices</li>
    <li>Testing on a device is very easy to set up</li>
    <li>Managing Flex states through the Design View can be helpful in visualing layouts</li>
    <li>Offers the familiarity and plugins of Eclipse</li>
</ul>
</li>
    <li><strong>ViewNavigator and View</strong> make navigating through applications using multiple views simple.  Using simple functions like pushView() and popView() you can move through your application and pass data with ease.  Check out these posts for a more in depth look at this powerful and intuitive interface:
<ul>
    <li><strong>Mihia Corlan</strong> - <a href="http://corlan.org/2011/01/12/understanding-flex-mobile-views-and-viewnavigator/" target="_blank">Understanding Flex Mobile View and ViewNavigator</a></li>
    <li><strong>Brian Rinaldi</strong> - <a href="http://www.remotesynthesis.com/post.cfm/passing-data-across-views-in-flex-mobile" target="_blank">Passing Data Across Views in Flex Mobile</a></li>
</ul>
</li>
    <li><strong>PersistenceManager</strong> alleviates the hassle of trying to manage data between view states by using Local Shared Objects. Even when your mobile OS decides to close your app for memory or power shortages, the PersistenceManager will preserve your designated data.  Check Jonathan Campos's post on it for more details: <a href="http://www.unitedmindset.com/jonbcampos/2010/11/01/flex-4-5-persistencemanager/" target="_blank">Flex 4.5 PersistenceManager</a></li>
    <li><strong>Flex 4 skinning</strong> is pretty damn nice, especially for someone like me who is about 95% developer, 5% designer.  Using MXML and AS3 you can create design and graphics for your components, keeping them separate from your UI's layout and logic.  This means you can effectively create vector skins using the AS3 drawing classes.  No more importing images just to create gradients and rounded corners.  Not as big a win for designers, but the pure developers out there will love this. Check out <strong>Ryan Frishberg's</strong> article for more details: <a href="http://www.adobe.com/devnet/flex/articles/flex4_skinning.html" target="_blank">Introducing skinning in Flex 4</a>.  The screenshot showing Repper below highlights entirely programmatic design.</li>

<li><strong>Multiscreen development</strong> potential is very appealing and Adobe is working to grow it further.  Christian Cantrell's demo video below shows what Adobe Air is capable of in terms of "code once, deploy everywhere."  Android, iPhone, iPad, Blackberry Playbook, Desktop, and web are all valid targets for your single code base.  While this is very exciting, it is also very young.  Take this all with a grain of mobile salt as this topic shows up again in the "Ugly" section.</li>
<iframe title="YouTube video player" width="640" height="390" src="http://www.youtube.com/embed/22vicDlzmkI" frameborder="0" allowfullscreen></iframe>
<h1><span style="font-weight: bold; font-size: 16px;">The Bad</span></h1>
<ul>
<li><strong>Lack of native component support</strong> can be a deal breaker for some people building mobile apps.  Its not for me nor for lots of people who are comfortable building their own components, but many want the native experience.  But all hope is not lost with the following AS3 libraries available that emulate native components:</li>
<table><tr><td style="vertical-align:middle; text-align:center;">
<br><strong>Nick Jonas</strong> - <a href="http://code.google.com/p/as3iphonecomponents/" target="_blank">as3iphonecomponents</a></td>
<td style="vertical-align:middle; text-align:center;"><br><strong>Kevin Hoyt</strong> - <a href="http://xperiments.es/blog/en/as3-android-flash-components/" target="_blank">android-components</a></td>
</tr></table>
<li><strong>Flex "Hero" is missing some core components</strong> that mobile developers will be expecting to be present. I for one was not expecting to have to build a modal select list from scratch.  Unfortunately, though, Flex "Hero" does not contain the mobile equivalent of a combobox.  You can create it with their scrollable List component paired with a semi-transparent background, but it would be nice to have this out of the box.  Other notable absentees are sliders and tabbed layouts.</li>
<li><strong>Not all native APIs are supported.</strong>  While this should be expected in a cross platform framework, it can sometimes lead to unexpected roadblocks.  In my case, I have only numeric input in my app.  I wanted to default the soft keyboard to the numeric keyset.  Unfortunately this is not possible in Air for Android.  It takes some AS3 parlor tricks just to keep the soft keyboard closed when you don't want it open on a TextInput focus.  There's even more to worry about with Apple development, but I'll mention that in the "Ugly" section.</li>
<li><strong>Simple things can be complicated.</strong> Take for example closing an app when a user leaves with the back button.  Seems easy enough, but it takes 3 event handlers to do it properly and even this method is <a href="http://blog.everythingflex.com/2010/10/13/exiting-an-air-on-android-application/" target="_blank">not without its problems</a>.  Check out the code I used below, thanks to <a href="http://www.flashrealtime.com/tip-close-your-android-air-app-on-back-button/" target="_blank">Tom Krcha</a>:

```  as3
protected function mobileapplication1_creationCompleteHandler(event:FlexEvent):void
{
    if(Capabilities.cpuArchitecture=="ARM")
    {
        NativeApplication.nativeApplication.addEventListener(Event.ACTIVATE, handleActivate, false, 0, true);
        NativeApplication.nativeApplication.addEventListener(Event.DEACTIVATE, handleDeactivate, false, 0, true);
        NativeApplication.nativeApplication.addEventListener(KeyboardEvent.KEY_DOWN, handleKeys, false, 0, true);
    }
}

private function handleActivate(event:Event):void
{
    NativeApplication.nativeApplication.systemIdleMode = SystemIdleMode.KEEP_AWAKE;
}

private function handleDeactivate(event:Event):void
{
    NativeApplication.nativeApplication.exit();
}

private function handleKeys(event:KeyboardEvent):void
{
    if(event.keyCode == Keyboard.BACK)
        NativeApplication.nativeApplication.exit();
}
```

</li>
<li><strong>Debugging on a device can be tricky.</strong>  So tricky in fact that I never got it working.  In all fairness, I didn't try to diagnose it any further after the getting the initial error because the app I was building was so simple.  But the fact remains that it didn't work out of the box for me.  Maybe your experience will be different and I welcome anyone to call me an idiot and tell me what I did wrong.</li>
</ul>

<h1><span style="font-weight: bold; font-size: 16px;">The Ugly</span></h1>
<ul>
<li><strong>Universal mobile device support is minimal at this point.</strong> Android is covered pretty well up through the Air 2.5 SDK, but iPhone/iPad only support Air up to version 2.0.2 via the <a href="http://labs.adobe.com/technologies/packagerforiphone/" target="_blank">Adobe Packager for iPhone</a>.  This leaves out key APIs like camera support and video/sound capture, not to mention the bevy of <a href="http://labs.adobe.com/wiki/index.php/Packager_for_iPhone:Release_Notes" target="_blank">bugs and gotchas</a> that you have to watch out for.  The workflow for deploying apps to iOS devices with the packager is also no picnic.  While the Blackberry Playbook is proudly supporting the Adobe developer community, there's been no official announcement, though there has been mention, of Flash or Air being on Blackberry smart phones.

Long and short, you aren't going to be hitting the widest part of the market when compared to other mobile frameworks like Appcelerator or PhoneGap.  And even if you do, I've experienced first hand how users can be put off by having to install Adobe Air on their phone for the sake of an app.  <span style="color:#ff0000;">Until Air for mobile devices support becomes more common place, it may be viewed as an unnecessary evil by many mobile users</span>.
</li>
<li><strong>Performance can be a problem for even the simplest apps.</strong>  This for me is the most critical area that needs to be improved before people will take Air seriously as a mobile framework.  Simple things like view transitions, scrolling, button interactions, etc... have a noticeable sluggishness that users won't stand for.  Even the cream of the crop among Flex Hero apps, like <a href="http://www.unitedmindset.com/jonbcampos/" target="_blank">Jonathan Campos's</a> nearly 100K user base NetFlix <a href="https://market.android.com/details?id=air.com.unitedmindset.QueueManager" target="_blank">Queue Manager</a>, is not immune to these problems.  Though a majority of the comments are very complimentary, the few detractors have a very common message: we don't want to install Adobe Air and we find it slower than native apps.  Are these types of comments the whole story?  Absolutely not.  Does that mean they can be ignored?  Absolutely not.  The vocal complainers, though not always very helpful, can sometimes spur the necessary advances that can take a product to the next level.
</li>
</ul>
<h1><span style="font-weight: bold; font-size: 16px;">Summary</span></h1>
Hey Adobe, fix the ugly, stay on top of the bad, and keep highlighting the good.

While I am far from swearing off AS3 and Flex development for mobile devices, I think Adobe has a long way to go before it will be able to bring in a significant amount of non-Adobe developers.  Their mobile platform and workflow seems as though it caters entirely to existing Flash and Flex developers.  There just doesn't seem to be an effort to bring in new blood from the outside.  And if that remains the same, Appcelerator, PhoneGap, Sensa Touch, jQuery Mobile, or whatever other platform that comes next and engages larger cores of developers will take away valuable relevance in this land grab for mobile supremacy.

]]></content>
  </entry>
  
</feed>
